This crate is designed to bridge the gap between gRPC's design principles and
the idiomatic Rust approach to data structures. It automates the generation of
"mirror" data structures that unwrap all necessary fields from `Option<T>` and
provides `TryFrom` implementations for converting from the original
autogenerated structs.

### Why This Matters

With the evolution of protobuf to version 3, the notion of required fields was
phased out. In the context of gRPC, this means every nested field in your
messages becomes optional by default. The rationale is to shift field validation
responsibilities from the protocol to the application level, avoiding the
complexities required fields introduce in evolving data contracts.

Prost and Tonic, adhering to these updated protobuf and gRPC conventions,
generate Rust data structures where non-primitive nested fields are encapsulated
in `Option<T>`. While this aligns with Rust's safety and nullability features,
it can be cumbersome, especially when certain fields are inherently required for
your data structures to be logically coherent. In Rust, the preferred paradigm
is to prevent invalid states at compile time, a goal not fully met by Prost's
autogenerated structs, which often lead to excessive unwrapping and referencing.

The proposed solution is to create "sanitized" mirror structures where all
essential fields are directly accessible, not wrapped in `Option`. By
implementing `TryFrom<OriginalMessage> for MirrorMessage`, these structures
adhere to Rust's design principles, ensuring data integrity and enhancing code
clarity.

The primary challenge with this approach is the extensive boilerplate code
required to create and maintain these mirror structures. This crate introduces a
procedural macro to eliminate this boilerplate, automatically generating the
necessary code, simplifying maintenance, and enabling you to focus on your
application's logic.

### How to

Here is an example protobuf file:

```proto
syntax = "proto3";
package foo.bar;

message A {
    int32 f1 = 1;
}

message B {
    A f1 = 1;
    A f2 = 2;
    repeated A f3 = 3;
}
```

When working with prost-generated structs, it's a good practice to organize the
generated code into nested modules that mirror your protobuf package structure.
For the example above, you should encapsulate the generated Rust code as
follows:

```rust
pub mod proto{
    pub mod foo {
        pub mod bar {
            // include generated code here
        }
    }
}
```

To leverage `prost-unwrap`, apply the `required` macro to the root module. The
attribute will generate a mirror module alongside the specified root module.

The `required` attribute required two arguments:

1. **Mirror Module Name:** The name of the module where the mirror structs will
   be generated.
2. **Fields Array:** An array of string literals specifying the fields to be
   unwrapped from `Option`. To save space one can also specify multiple fields
   of one struct in braces. The following parameters are equivalent:
   - `["mod1.mod2.struct.field1", "mod1.mod2.struct.field2"]`
   - `["mod1.mod2.struct.{field1, field2}"]`

#### Unwrapping the fields

For the example protobuf definition above:

```rust
#[prost_unwrap::required(mirror, ["foo.bar.B.f1"])]
pub mod proto{
    pub mod foo {
        pub mod bar {
            // include generated code here
        }
    }
}
```

`prost-unwrap` will generate the mirror of every struct and enum it will find
while traversing. All the fields found in attribute arguments will be unwrapped
from `Option<T>` and will be typed as `T` instead, and everything else
(including the structs and fields attributes) will be copied.

The generated module (`mirror`) will be located inside the root module
(`proto`), like this:

```rust
pub mod proto{
    pub mod foo {
        pub mod bar {
            // include generated code here
        }
    }
    pub mod mirror {
        pub mod foo {
            pub mod bar {
                // ...
            }
        }
    }
}
```

For the example protobuf file above the original struct

```rust
pub struct A {
    pub f1: i32
}
pub struct B {
    pub f1: Option<A>,
    pub f2: Option<A>,
    pub f3: Vec<B>
}
```

The mirror structure will look like this:

```rust
pub struct A {
    pub f1: i32
}
pub struct B {
    pub f1: A,
    pub f2: Option<A>,
    pub f3: Vec<B>
}
```

#### Casting

`prost-unwrap` will generate the following trait implementations for every
struct and enum:

- `TryFrom<OrigT> for MirrorT`, enabling you to cast original struct with
  `try_into`.
- `Into<OrigT> for MirrorT`, enabling you to cast mirror struct back to original
  one with `into`.

Refer to [`casting`](tests/casting.rs) tests for examples.

Repeated fields, which are represented with `Vec<OrigT>` type, will also be
casted to `Vec<MirrorT>`.

#### Errors

The `TryFrom` trait implementation might return an error. This error is also
generated by `prost-unwrap`, and is located inside the mirror module root
(`mirror::Error`).

#### Related repositories

[prost-unwrap-transform](https://github.com/spawn-link/prost-unwrap-transform):
proc-macro wrapper for `prost-unwrap`.

[prost-macro-core](https://github.com/spawn-link/prost-unwrap-core): procedural
code generation implementation.
