This crate is designed to bridge the gap between gRPC's design principles and
the idiomatic Rust approach to data structures. It automates the generation of
"mirror" data structures that unwrap all necessary fields from `Option<T>` and
provides `TryFrom` implementations for converting from the original
autogenerated structs.

### Why This Matters

With the evolution of protobuf to version 3, the notion of required fields was
phased out. In the context of gRPC, this means every nested field in your
messages becomes optional by default. The rationale is to shift field validation
responsibilities from the protocol to the application level, avoiding the
complexities required fields introduce in evolving data contracts.

Prost and Tonic, adhering to these updated protobuf and gRPC conventions,
generate Rust data structures where non-primitive nested fields are encapsulated
in `Option<T>`. While this aligns with Rust's safety and nullability features,
it can be cumbersome, especially when certain fields are inherently required for
your data structures to be logically coherent. In Rust, the preferred paradigm
is to prevent invalid states at compile time, a goal not fully met by Prost's
autogenerated structs, which often lead to excessive unwrapping and referencing.

The proposed solution is to create "sanitized" mirror structures where all
essential fields are directly accessible, not wrapped in `Option`. By
implementing `TryFrom<OriginalMessage> for MirrorMessage`, these structures
adhere to Rust's design principles, ensuring data integrity and enhancing code
clarity.

The primary challenge with this approach is the extensive boilerplate code
required to create and maintain these mirror structures. This crate introduces a
procedural macro to eliminate this boilerplate, automatically generating the
necessary code, simplifying maintenance, and enabling you to focus on your
application's logic.

### How to

When working with prost-generated structs, it's a good practice to organize the
generated code into nested modules that mirror your protobuf package structure.
For instance, if you have a protobuf package named `foo.bar`, you should
encapsulate the generated Rust code as follows:

```ignore
mod foo {
    mod bar {
        tonic::include_proto!("foo.bar");
    }
}
```

To leverage `tonic_required`, apply it to the root module encompassing all your
`include_proto!` calls. The attribute will generate a mirror module alongside
the specified root module.

#### Attribute Arguments

`tonic_required` requires three arguments:

1. **Mirror Module Name:** The name of the module where the mirror structs will
   be generated.
2. **Fields Array:** A list of strings specifying the fields to be unwrapped
   from `Option`.
3. **Error Type:** The type of error to return from the `TryInto` implementation
   if an error occurs. This type must be fully qualified.

#### Naming Conventions

When specifying field names, start from the root module where `tonic_required`
is applied. In contrast, the error type must be fully qualified to sidestep
unnecessary imports. This distinction is due to the nuances of how Rust's
procedural macros operate.

### Example Usage

```ignore
pub mod root {
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("Struct is insane: {reason}")]
        SanityError { reason: &'static str },
    }

    #[tonic_required_fields::tonic_required(sane, [
        "foo.Foo.z",
        "foo.bar.Bar.b"
    ], crate::root::Error)]
    pub mod foo {
        pub struct Foo {
            x: String,
            y: i32,
            z: std::option::Option<u16>,
        }
        pub mod bar {
            pub struct Bar {
                a: std::option::Option<String>,
                b: std::option::Option<super::Foo>,
            }
        }
    }
}
```

After processing with `tonic_required`, a new `root::sane` module will be
created, housing the mirror structs with their necessary fields unwrapped.
Additionally, `TryFrom` implementations will be provided for converting the
original structs to their mirror counterparts.
